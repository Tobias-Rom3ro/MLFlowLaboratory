MODELO: deepseek/deepseek-chat-v3.1:free
TEMPERATURA: 0.7
LATENCIA: 24.649s
================================================================================

Claro, aquí tienes una implementación del algoritmo de búsqueda binaria en Python con comentarios explicativos:

```python
def busqueda_binaria(arr, objetivo):
    """
    Implementación del algoritmo de búsqueda binaria.

    Parámetros:
    arr (list): Una lista ordenada de elementos.
    objetivo: El elemento que se desea encontrar en la lista.

    Retorna:
    int: El índice del elemento objetivo en la lista si se encuentra, de lo contrario -1.
    """
    
    # Inicializar los índices de los límites de la búsqueda
    izquierda = 0
    derecha = len(arr) - 1

    # Continuar la búsqueda mientras el rango sea válido
    while izquierda <= derecha:
        # Calcular el punto medio del rango actual
        medio = (izquierda + derecha) // 2

        # Verificar si el elemento en el punto medio es el objetivo
        if arr[medio] == objetivo:
            return medio  # Retornar el índice del elemento encontrado

        # Si el objetivo es menor que el elemento en el punto medio,
        # ajustar el límite derecho para buscar en la mitad izquierda
        elif arr[medio] > objetivo:
            derecha = medio - 1

        # Si el objetivo es mayor que el elemento en el punto medio,
        # ajustar el límite izquierdo para buscar en la mitad derecha
        else:
            izquierda = medio + 1

    # Si el bucle termina sin encontrar el objetivo, retornar -1
    return -1

# Ejemplo de uso
if __name__ == "__main__":
    lista_ordenada = [1, 3, 5, 7, 9, 11, 13, 15]
    objetivo = 7
    resultado = busqueda_binaria(lista_ordenada, objetivo)
    
    if resultado != -1:
        print(f"El elemento {objetivo} se encuentra en el índice {resultado}.")
    else:
        print(f"El elemento {objetivo} no se encuentra en la lista.")
```

### Explicación del código:

1. **Inicialización**: Se inicializan dos punteros, `izquierda` y `derecha`, que representan los límites de la búsqueda en la lista ordenada.

2. **Bucle `while`**: El bucle continúa ejecutándose mientras el rango de búsqueda sea válido (es decir, mientras `izquierda` sea menor o igual a `derecha`).

3. **Cálculo del punto medio**: En cada iteración, se calcula el índice medio del rango actual. Esto se hace sumando los índices `izquierda` y `derecha` y dividiendo por 2.

4. **Comparación**: 
   - Si el elemento en el índice `medio` es igual al `objetivo`, se retorna el índice `medio`.
   - Si el elemento en `medio` es mayor que el `objetivo`, se ajusta el límite `derecha` para buscar en la mitad izquierda del rango.
   - Si el elemento en `medio` es menor que el `objetivo`, se ajusta el límite `izquierda` para buscar en la mitad derecha del rango.

5. **Finalización**: Si el bucle termina sin encontrar el `objetivo`, se retorna `-1` para indicar que el elemento no está en la lista.

### Ejemplo de uso:
En el ejemplo proporcionado, se busca el número `7` en una lista ordenada. Si el número se encuentra, se imprime su índice; de lo contrario, se indica que no está en la lista.

Este algoritmo tiene una complejidad temporal de \(O(\log n)\), lo que lo hace muy eficiente para listas grandes.
