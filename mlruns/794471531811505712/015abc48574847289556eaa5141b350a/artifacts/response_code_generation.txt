MODELO: gemini-2.0-flash-exp
TEMPERATURA: 0.7
LATENCIA: 9.609s
================================================================================

```python
def busqueda_binaria(lista, objetivo):
  """
  Implementa el algoritmo de búsqueda binaria en una lista ordenada.

  Args:
    lista: Una lista ordenada en la que buscar.
    objetivo: El valor que se está buscando.

  Returns:
    El índice del objetivo en la lista si se encuentra, de lo contrario, retorna -1.
  """

  izquierda = 0  # Índice del inicio de la lista
  derecha = len(lista) - 1  # Índice del final de la lista

  while izquierda <= derecha:
    # Calcula el punto medio (evitando posibles desbordamientos con (izquierda + derecha) // 2)
    medio = izquierda + (derecha - izquierda) // 2

    # Compara el valor del punto medio con el objetivo
    if lista[medio] == objetivo:
      return medio  # Se encontró el objetivo, retorna su índice
    elif lista[medio] < objetivo:
      # El objetivo es mayor, busca en la mitad derecha de la lista
      izquierda = medio + 1
    else:
      # El objetivo es menor, busca en la mitad izquierda de la lista
      derecha = medio - 1

  # Si el bucle termina sin encontrar el objetivo, significa que no está en la lista
  return -1  # Retorna -1 para indicar que el objetivo no se encontró


# Ejemplo de uso:
lista_ordenada = [2, 5, 7, 8, 11, 12]
objetivo = 13

indice = busqueda_binaria(lista_ordenada, objetivo)

if indice != -1:
  print(f"El objetivo {objetivo} se encuentra en el índice {indice}")
else:
  print(f"El objetivo {objetivo} no se encuentra en la lista")

objetivo = 11

indice = busqueda_binaria(lista_ordenada, objetivo)

if indice != -1:
  print(f"El objetivo {objetivo} se encuentra en el índice {indice}")
else:
  print(f"El objetivo {objetivo} no se encuentra en la lista")
```

**Explicación detallada del código:**

1. **`def busqueda_binaria(lista, objetivo):`**:  Define la función `busqueda_binaria` que toma dos argumentos:
   - `lista`: La lista ordenada donde se va a buscar.  **Importante:** La búsqueda binaria solo funciona en listas *ordenadas*.
   - `objetivo`: El valor que se está buscando dentro de la lista.

2. **`izquierda = 0`**: Inicializa la variable `izquierda` al índice 0, que representa el inicio de la lista.

3. **`derecha = len(lista) - 1`**: Inicializa la variable `derecha` al índice del último elemento de la lista. `len(lista)` devuelve la longitud de la lista, y restamos 1 porque los índices comienzan en 0.

4. **`while izquierda <= derecha:`**:  Este es el bucle principal de la búsqueda binaria.  Continúa iterando mientras el índice `izquierda` sea menor o igual que el índice `derecha`.  Esto significa que todavía hay una porción de la lista en la que buscar.

5. **`medio = izquierda + (derecha - izquierda) // 2`**: Calcula el índice del elemento del medio de la porción de la lista que estamos considerando.  Es importante usar `(derecha - izquierda) // 2` en lugar de `(izquierda + derecha) // 2` para evitar posibles desbordamientos de enteros, especialmente con listas muy grandes.  `//` realiza la división entera (devuelve solo la parte entera del resultado).

6. **`if lista[medio] == objetivo:`**:  Compara el valor del elemento en el índice `medio` con el `objetivo` que estamos buscando. Si son iguales, significa que encontramos el `objetivo`.

7. **`return medio`**: Si el `objetivo` se encuentra, la función retorna el índice `medio` donde se encontró.

8. **`elif lista[medio] < objetivo:`**: Si el valor en el índice `medio` es menor que el `objetivo`, significa que el `objetivo` (si existe en la lista) debe estar en la mitad derecha de la lista (después del índice `medio`).

9. **`izquierda = medio + 1`**:  Actualiza el índice `izquierda` para que apunte al siguiente elemento después del `medio`.  Esto efectivamente descarta la mitad izquierda de la lista.

10. **`else:`**: Si el valor en el índice `medio` es mayor que el `objetivo`, significa que el `objetivo` (si existe en la lista) debe estar en la mitad izquierda de la lista (antes del índice `medio`).

11. **`derecha = medio - 1`**: Actualiza el índice `derecha` para que apunte al elemento anterior al `medio`.  Esto efectivamente descarta la mitad derecha de la lista.

12. **`return -1`**: Si el bucle `while` termina sin encontrar el `objetivo`, significa que el `objetivo` no está presente en la lista. En este caso, la función retorna `-1`.  Este valor `-1` se usa convencionalmente para indicar que la búsqueda falló.

**Características clave de la búsqueda binaria:**

* **Eficiencia:** La búsqueda binaria es muy eficiente para listas ordenadas. Tiene una complejidad de tiempo de O(log n), donde n es el número de elementos en la lista.  Esto significa que el tiempo de búsqueda aumenta muy lentamente a medida que la lista se hace más grande.
* **Lista ordenada:**  **Requisito fundamental:** La búsqueda binaria solo funciona correctamente si la lista está ordenada. Si la lista no está ordenada, la búsqueda binaria puede devolver resultados incorrectos o no encontrar el objetivo incluso si está presente.
* **Divide y vencerás:** La búsqueda binaria es un ejemplo de un algoritmo de "divide y vencerás". Divide repetidamente la lista en dos mitades y solo busca en la mitad que podría contener el objetivo.

**Cómo funciona la búsqueda binaria (ejemplo):**

Supongamos que queremos buscar el número 11 en la lista ordenada `[2, 5, 7, 8, 11, 12]`.

1. `izquierda = 0`, `derecha = 5`
2. `medio = (0 + 5) // 2 = 2`. `lista[2] = 7`.  Como 7 < 11, buscamos en la mitad derecha. `izquierda = 3`
3. `medio = (3 + 5) // 2 = 4`. `lista[4] = 11`.  Como 11 == 11, encontramos el objetivo.  Retornamos el índice 4.

